
----------------------------------------
Java is Platform Independent
----------------------------------------

	-> Java is renowned for its platform independence, which means that compiled Java code can run on various platforms without requiring recompilation. 
	-> Here’s how it achieves this remarkable feature:

	Bytecode Generation:
		=> When you write Java source code (with a .java extension), it is first compiled by the Java compiler (javac). 
		=> The compiler translates the human-readable code into an intermediate form called bytecode.
		=> Bytecode is a machine-independent representation of the program logic. It’s not specific to any operating system or hardware architecture.

	Java Virtual Machine (JVM):
		=> The JVM plays a crucial role in making Java platform-independent.
		=> Each operating system has its own JVM implementation (custom-built for that OS).
		=> The JVM interprets and executes the bytecode produced by the compiler.
	
	Execution Process:
		=> Here’s a step-by-step breakdown of how Java code is executed:
			-> Compilation: The Java compiler converts the source code into bytecode (.class files).
			-> Class Loader: The class loader loads the main class (containing the main method) and other referenced classes into memory.
			-> Bytecode Verifier: The bytecode verifier ensures that the loaded bytecode adheres to safety rules (e.g., no illegal instructions).
			-> Just-In-Time (JIT) Compiler: The JIT compiler translates bytecode into native machine code specific to the host system. 
										This translation happens dynamically during runtime.
			-> Execution: Finally, the native machine code is executed by the CPU.

	Platform Independence:
		=> The class files (bytecode) generated by the compiler are independent of the underlying OS.
		=> As long as a compatible JVM exists for a given platform, the bytecode can run seamlessly on Windows, Linux, macOS, or any other supported system.

----------------------------------------
Java Advantages and DisAdvantages
----------------------------------------
	Advantages:
		-> Platform Independent, Object Oriented, Security, Enterprise Level Application.
		-> Build in thread support.
	DisAdvantages:
		-> Slow compare to C++ because of JVM and Memory Management.
		-> Java's automatic memory management leads to slower performance & increased memory usage.
		-> Multiple inhertance is partially done.

----------------------------------------
JDK in Java
----------------------------------------
	 _______________________________________________
	|												|
	|	 _______________________________			|
	|	|	 ______________			JRE	|			|
	|	|	|			   |			| + 		|
	|	|	|			   | + Library	|Development|
	|	|	|			   |	Classes	|	Tools	|
	|	|	|			   |			|			|
	|	|	|	  JVM	   |			|			|
	|	|	|			   |			|			|
	|	|	|			   |			|			|
	|	|	|			   |			|			|
	|	|	|			   |			|			|
	|	|	|			   |			|			|
	|	|	|______________|			|			|
	|	|								|			|
	|	|								|			|
	|	|_______________________________|			|
	|						JDK						|
	|_______________________________________________|

JDK:
	-> Used for developing Java Based applications and applets.
	-> JDK Components
		1. JRE	
			=> Provides an environment used to run Java applications.
			=> It is used to run the compiled programs (.class files)
		2. Development Tools:
			=> 
		3. Compiler(javac): 
			=> JDK contains the compiler called javac which translated source code to bytecode executed on JVM.
			
		4. Achiever(JAR):
			=> JAR tools used to create JAR files, which bundles the Java class files together.
		5. Other Resources:
			=> javac, JVM, Java Archiever, javadoc, jdb(Debugger), 
JRE: 
	-> JRE is primarly focused on running Java application.
	-> It is all about runtime execution.
	-> Key components of JRE:
		1. JVM
			=> Interprets the Java bytecode and executes it on host machine.
		2. Java Class Libraries
			=> Pre-compiled classes and methods that Java application can use 
		3. Core Java API's
			=> JRE includes essentials API's for tasks like I/O networking, database access.

NOTE: JDK and JRE both are platform dependent. Different OS will have their different JRE and JDK.

JVM:
	-> JVM is an abstract machine which provides the runtime environment in which Java bytecode can be executed.
	-> JVM are available for various hardware and software, making them platform dependent.
	Key Points:
		=> JVM's behaviour is specified, but the implementation can vary among different providers.
		=> JVM's Implementation is the part of JRE
		=> We run a Java program using "java" command, an instance of the JVM gets created.
	JVM's Operation
		=> Load the Java bytecode(.class files)
		=> Verifies the bytecode (security and structural rules)
		=> Translates byte code in native machine code.
	JVM's Architecture 
		=> Class Loader
		=> Heap, Stack, Garbage Collector, 
		=> JNI(Java Native Interface) => Allows interactions with the native libraries(utils packages and all).

	JIT(Just in Time Compiler):
		Converts the bytecode to machine code.
		Optimise the performance
		
----------------------------------------
Memory Management in Java
----------------------------------------
	Stack Memory
		=> Stack memory is a region of memory allocated to each thread when it is created.
		=> Purpose: It stores information related to method execution and local variables.
		=> Order: Follows a First-In-Last-Out (FILO) order.
		=> Lifetime: Variables in the stack live until the function returns.
		=> Scope: Limited to the thread where it was created.
		=> Error: If there’s no space left for new objects, it throws a java.lang.StackOverflowError.
		
		=>  Local primitive variables and references to objects (within methods).
			--> Refrences of the Object 
			Person per1 = new Person() In this example per1 is created in Stack memory and instance is created in Heap. per1 is storing the heap address inside it.
	
	Heap Memory
		=> Heap memory is created when the JVM starts and is used by the application throughout its lifetime.
		=> Purpose: It stores objects (like instances of classes) and JRE classes.
		=> Order: No fixed order; dynamically manages memory blocks.
		=> Garbage Collection: Automatically deletes objects no longer in use.
		=> Lifetime: Objects in heap memory live until program termination or memory freeing.
		=> Global Accessibility: Elements in heap memory are accessible across the entire
		
		=> Objects(instance of classes) and non-premitive types are stored on heap.
		=> When you create an object (using new), memory for that object is allocated on the heap.
	
	Performance:
		Fetching the value from stack memory is faster compare to Heap Memory. Objects in heap require additional memory allocation and deallocation.
	Memory Management:
		Understanding where data is stored helps to manage memory efficiently. Stack Memory is managed by JVM and Heap memory is managed by Garbage Collector.
		
	Method Area(Class Area):
		=> Part of heap space where it stores details about the 
			class structures => fully qualified name of classes, super class details, Access modifiers
			static variables => Static variables, final fields,
			constants, method code => Bytecode of the methods & constructor

----------------------------------------
Garbage Collection
----------------------------------------
	-> Is is a process in which Java programs perform automatic memory management.
	-> Heap memory is managed by the Garbage Collector.
	-> The garbage collector identifies and deletes unused aobjects to free up memory.
	
	-> Object is considered as unreachable if it does not have any refrences pointing to it.
	-> Eg: Person p1 = new Person(); p1 = null; Person instance that was created in heap becomes suitable for garbage collection.

----------------------------------------
Class Path and File Path
----------------------------------------
	Class Path
		-> Class Path is the list of directory locations that the Java Runtime Environment(JRE) searches for classes and other resource file during program execution.
		-> By default class path is set to the current working directory. We can customize to include additional directories or JAR files where your compiled
			classes or libraries resides.
		-> The classpath ensures that the Java Virtual Machine (JVM) knows where to find the compiled class files when you use them in your code.
		-> There are two types of classes present
			=> Standard Library Classes
				* java.util package is the part of standard library which is automatically available to JVM without the need to specify in the ClassPath.
				
			=> User defined or Third Party classes
				* CLASSPATH environment variables is used to specify the locations of user defined classes and third party libraries that are not part of
					standard library.
				* While running the Java Program, JVM uses this CLASSPATH to locate these classes.
	
	File Path
		-> Represents the location of the file or directory in the system.
		-> In Java Path class (from java.io.file) provides the programmatic representation of the file path.
		-> File path can be absolute(starting from the root directory) or relative(relative to the current working directory).

---------------------
Java is both interpreted and compiled language
---------------------
	-> Using command "javac" we compile the code and convert it in to bytecode.
	-> This byte code is interpreted in the machine code by the JVM.

The Java platform has two components:
	# The Java Virtual Machine
	# The Java Application Programming Interface (API)

1) Variable
	
	There are two types of Data Types 
		https://www.geeksforgeeks.org/data-types-in-java/
		
	1) Premitive Data Type (Built In data type)
		-> There are total 8 primitive data types.
			* boolean		(1 bit)
			* byte			(1 byte)
			* char			(2 byte)
			* short			(2 byte)
			* int			(4 byte)
			* long			(8 byte)
			* float			(4 byte, upto 7 decimal digits)
			* double		(8 byte, upto 16 decimal digits)
			
		-> Primitive data types in Java are immutable. This means that once a primitive value is assigned, it cannot be changed. 
			Instead, any operation that seems to modify the value actually creates a new value.
			
		-> Java follows the Unicode System not the ASCII code system. ASCII just requires the 1byte to represent all the character that is why 8bits are 
			not enough for java to represent all the characters.
		
		-> int > float > double 	Easily Converted
		-> Use TypeConversion if wants float in int eg: int a = (int) 20.22;
		
	2) Non-Premitive Data Type (Object Data Type, Reference Data Types)
		-> Reference data types do not store the value directly; instead, they store a memory address (or reference) pointing to the actual data elsewhere in memory.
		-> Examples: String, Class, Interface, Array
		
	Java Identifiers
		-> Only contain Alphanumeric (A-Z, a-z, 0-9), $, _.
		-> Should not start with numbers. It is case sensitive.
		-> No limit to the size of identifiers. 
		-> No reserved word whould be used.
	
	There are three types of variables:
		Local Variable
			-> Defined inside a specific block.
		Instance Variable
			-> Defines inside a class. Created once the object is created.
		Static Variable
			-> Defined inside a class. But does not require an object to created.
			-> You can call static variable using Class name or with the instance created(compiler will shown an warning program wont halt. Compiler will append
				the class name in the call.)
	
	Wrapper Classes in Java	
		-> They convert primitive data types in to objects. Data structure in the collections framework like ArrayList, Vector stores objects not premitive types.
		-> There are 8 Wrapper classes in Java. (Character, Byte, Short, Integer, Long, Float, Double, Boolean)
		
		Advatages of Wrapper Classes:
			-> Collection only allowed on Serialization.
			-> Cloning process only objects.
			-> Objects can have multiple methods.
			-> Serialization only allow object data.
		
		AutoBoxing & Unboxing
			-> Conversion of primitive type to an object of their corresponding wrapper classes is known as autoboxing.
			-> Reverse process of Autoboxing is known as Unboxing.
			
2) Operators
		-> Arithmetic Operator 	(+, -, *, /, %)
		-> Unary Operator		(++, --, !)
		-> Assisgnment Operator (+=, -=, *=, /=)
		-> Relational Operator	(==, >=, <=, >, <)
		-> Logical Operator		(&&, ||, !)
		-> Ternary Operator		(? :)
		-> Bitwise Operator		(&, |, ^, ~)
		-> Shift Operator		(>>, >>>, <<)
		-> instanceof Operator	
		
	Difference between >> and >>> (Right Shift operations)
	
2.1 Java Keywords
	https://www.javatpoint.com/java-keywords
	

3) Switch Statement
	https://geeksforgeeks.org/switch-statement-in-java/
	
	=> Switch the cases must have the same data type as the choice. Cases should not be duplicate else it will endup having an error.
	=> Cannot use the variable inside the choice. The value for the case must be constant or literal.
	=> char, byte, int, short, long, enums, String can be used at place of Choices
	=> We can also use wrapper classes in choice but need to pass the exact value like Integer.getInt() in choice.
	=> Cannot pass null in the switch statement. Cannot return inside the switch statement.

4) break
	1) Simple break to break a loop
	2) We can use break along with the labels

5) continue
	1)Continue with labels

6) comments
	* Single Line Comment	* Multiline comment
	IMP
	// \u000d System.out.println("Java comment is executed!!");  
	This line will print instead of being commented because \u000d will take it to the next line

7) new keyword
	* The new keyword is used to allocate memory at runtime. All objects get memory in Heap memory area.

									--------------------------------------
												OOPS in JAVA
									--------------------------------------
Pillars of OOPS
	-> Encapsulation
	-> Inheritance
	-> Polymorphishm
	-> Abstraction

									--------------------------------------
												ENCAPSULATION
									--------------------------------------

8) Constructor
	-> A Java constructor cannot be abstract, static, final, and synchronized
	-> If there is no constructor in a class, compiler automatically creates a default constructor.
	-> Constructor can create object, start a thread, calling a method and can perform any operations in an Constructor as we perform in method
	
	#Copy the values of one object to the another object in Java
	-> Use .copy() method of object class
	
	#Does constructor return any value?
	-->Yes, it is the current class instance (You cannot use return type yet it returns a value).

9) static can be 
	--> Static Variable (also known as a class variable)
		# Gets Memory only once
		# Saves Memory
		
	--> Static Method (also known as a class method)
		# A static method belongs to the class rather than the object of a class.
		# A static method can be invoked without the need for creating an instance of a class.
		# A static method can access static data member and can change the value of it.
	 	# The static method can not use non static data member or call non-static method directly.
		# this and super cannot be used in static context({}).
		# We can call static method present inside base class from the child class
		# main() is define as static so that JVM dont allocate the extra memory 

	--> Static Block
		Is used to initialize the static data member.
		It is executed before the main method at the time of classloading.
		
		Q) Can we execute a program without main() method?
			No, one of the ways was the static block, but it was possible till JDK 1.6.
			Since JDK 1.7, it is not possible to execute a Java class without the main method.

	--> Static Nested class
		

10) this
	Used to invloke constructor
	Sets value in a class variable from a local variable
	if calling another construtor then Call to this() must be the first statement in constructor.
	we can pass this as a parameter in methods or in constructor
	this returns the current class instance
	
									--------------------------------------
												INHERITANCE
									--------------------------------------
									
11)Inheritance(IS-A Relationship)

	Q) Why Multiple Inheritance is not supported in java ?
	  --> To reduce the complexity and simplify the language, multiple inheritance is not supported in java.
	  --> Always the child is linked to a parent Class by one of its constructor.
		If no constructor is present then JVM adds the default no-args constructor in it
		See below Example
	

	class Parent{								|	class Parent{
		Parent(int a, int b){					|		Parent(int a, int b){
			System.out.println("Parent Class");	|			System.out.println("Parent Class");
		}										|		}	
	}											|	}
												|
	class Child extends Parent{					|	class Child extends Parent{
												|		//Error initialize a constructor in Child with same as Parent and call super(int a, int b)
		Child(){			 					|
			//Error	default	constructor in 		|
			// parent not present				|	}
												|
			System.out.println("Child Class");	|
		}										|
	}											|

12) Aggregation in Java(HAS-A Relationship)

	--> Class has an entity refrence
	--> Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; 
	    otherwise, aggregation is the best choice.
	--> Aggregation represents a “has-a” relationship where one object contains another object. 
		However, the contained object can exist independently of the container.
	--> Example: A Library and Books. A library has books, but if the library is destroyed, the books can still exist independently.
	--> In case of Aggregation it is One to Many Relationship which means an element can or can not exists. (In Java it is List<Books>)
	
	Composition in Java
	--> This also represnts the Has-A relationship but it is stronger version of assocation while the Aggregation is the weaker version of assocation.
	--> In Composition the lifecycle of the contained object is managed by the container object.
	--> Eg: Car has a engine incase of Composition, engine instance cannot be created outside of the Car object. While in Association the Engine object can be 
	created outside of the Car object.
	--> In case of Composition it is one to one relationship in SQL. Which means foreign key reference (In Java it is (public Engine engine))

13) Method Overloading - Compile Time Polymorphishm

	Method Overloading can be achieved:
		--> By changing number of arguments.
		--> By changing the data type of an argument.
	
	NOTE:
	--> In Java, Method Overloading is not possible by changing the return type of the method only.
		Eg : public int add(int a,int b){return a+b;}
		     public double add(int a,int b){return a+b;}
	Compile Time Error is better than Run Time Error. 
	So, java compiler renders compiler time error if you declare the same method having same parameters.
	--> We can overload main() method as well but JVM will call only String args[]
	--> Method Overloading does 

	#Type Promotion in Method Overloading
	-->https://www.javatpoint.com/method-overloading-in-java
	
	One type is not de-promoted implicitly for example double cannot be depromoted to any type implicitly.

14)Method Overriding - Run Time Polymorphishm
	--> Method Overridding
			-> Must have same name as the parent class.
			-> Method must have the same parameter as in the parent class.
			-> There must be a IS-A relationship.
	Note: The return type could be different but the childs return type should be covariant to parents return type.
	
	--> Java method overriding is mostly used in Runtime Polymorphism
	--> Static Method cannot be overridden. It is because the static method is bound with class whereas instance method 
	    is bound with an object. Static belongs to the class area, and an instance belongs to the heap area.
	--> We cant ovveride main method in Java because it is static.
	
15) Covariant Return Types
	--> In case of Method overriding Child methods return type can be different of parent return type, but the child class return type should be an 
		instance of parents return type	
	--> For example, 
	class Animal {
		public Animal getAnimal(String name){
			return new Animal(name);
		}
	}
	
	class Dog extends Animal{
		public Dog getAnimal(){			// Overridden Method here Dog is an covariant return type.
			return new Dog();
		}
	}
RadhaRani

16) super keyword in Java
	--> Whenever you create the instance of subclass, an instance of parent class is created implicitly which is referred 
	   by super reference variable.
	--> super() is added in each class constructor automatically by compiler if there is no super() or this().

17) There are three places in java where you can perform operations:
	1) Methods
	2) Constructor
	3) Block

18) Instance Initializer Block
	-->https://www.javatpoint.com/instance-initializer-block
	# Class B extends class A{													Class B extends class A{ 
	
		B() {						      				Compiler Converts			B(){
			System.out.println("Constructor Called");  	this to 						super();
														------------>					{ System.out.println("Block Called"); }
		}																				System.out.println("Constructor Called");
		{System.out.println("Block Called")}										}	
		
	}																			}

    Rules of Instance intializer Block:
	1) The instance initializer block is created when instance of the class is created.
	2) The instance initializer block is invoked after the parent class constructor is invoked (i.e. after super() constructor call).
	3) The instance initializer block comes in the order in which they appear.First block will be printed first and then so on

19) final keyword
	--> Final can be a method, class and variable
	final Variable
		--> If you make any variable as final, you cannot change the value of final variable(It will be constant).
		--> A final variable that is not initialized at the time of declaration is known as blank final variable.
		--> If variable is final then it is mandatory to initialize its value
		--> final variable can be initialized at the time of creation or in an Constructor / Parameterized Constructor
		--> Once initialized no one can change its value 
		--> The blank final variable can be static also which will be initialized in the static block only
		--> If you want to create a variable that is initialized at the time of creating object and once initialized may not be changed, 
		    it is useful. For example PAN CARD number of an employee.
		
		Note: Final variable can be accessed from Child class.
	final method
		--> Can not ovverride
		--> Constructor cannot be final because constructor is never inherited


20) Runtime Polymorphism / Dynamic Method Dispath
	--> is a process in which a call to an overridden method is resolved at runtime rather than compile-time.

21) TypeCasting:
	--> Convert one data type to another
	--> Two Types UpCasting and DownCasting
	--> We can perform Upcasting implicitly or explicitly, but downcasting cannot be implicitly possible.


			Parent				Parent
			   ^ 				  |
			   |				  |
			   |(UpCasting)		  |(Down Casting)
			   |				  |
			   |				  V
			 Child				Child


UpCasting 
	--> If the reference variable of Parent class refers to the object of Child class, it is known as upcasting.
		Eg: Parent p1 = new Child();
	--> Child object is typecasted to a parent class object.
	--> Upcasting is also known as Generalization and Widening.
	--> We cannot access all the members of Child class]
	--> It can access only the Parent class methods and the overridden methods of child class

DownCasting
	--> assign a parent class reference object to the child class. We cant do this but it wont raise any compile time error but will raise
	runtime error "ClassCastException"
	Eg:
	Parent c1 = new Child();
	c1.getName();					//Overridden method
	System.out.println(c1.setName());
	if(c1 instanceof Child) {
		Child c = (Child) c1;
		c.checkChild();                          //checkChild() is only present in Child Class
	}


22) Static and Dynamic Binding
23) instanceof
24) Abstract Class
	--> Abstract class 
			-> Can have abstract and non-abstract method.
			-> Can have constructor and static methods.
			-> It cannot be instantiated
	--> An abstract class can have a data member, abstract method, method body (non-abstract method), constructor, and even main() method.
	--> If there is an abstract method in a class, that class must be abstract.
	--> If you are extending an abstract class that has an abstract method, you must either provide the implementation of the method or make 
	    this class abstract.
	--> Abstract class can implement the interface. The abstract class can also be used to provide some implementation of the interface. 
	    In such case, the end user may not be forced to override all the methods of the interface.
	
	Questions:
		What is the use of having constructor if we can not instantiate ?
			-> We can call the abstract class constructor from the child class via the super keyword.
	
25) Interface 
	--> It also represents IS-A Relationship
	--> All methods are abstract.
	--> All variables are public, static and final by default
	--> Can have abstract methods and variables. Cant be instantiated.
	--> Interface can not have Constructor.
	--> Class implements interface must implement all the methods declarations
	--> Since Java 8, we can have default and static methods in an interface.
	    Since Java 9, we can have private methods in an interface.
	--> The Java compiler adds public and abstract keywords before the interface method. 
	    Moreover, it adds public, static and final keywords before data members.
	--> Class extends class, Interface extends Interface, Class implements interface

	Default Method in Interface
	--> Since Java 8, we can have method body in interface. But we need to make it default method

	Static method in Interface
	--> Contains body
	
	Marker / Tagged Interface
	An interface which has no member is known as a marker or tagged interface, for example, Serializable, Cloneable, Remote, etc. 
	They are used to provide some essential information to the JVM so that JVM may perform some useful operation.

	Nested Interface

26) Package
	-> We can group the list of class files in to Packages.
	-> Helps in
		* Namespace management
		* Access Protection
		* Code Reusability
		* Avoiding Name conflicts
	-> The JVM creates a directory named as package_name and places the compiled class file inside it.
	-> To create a subpackage we need to write "package dsa.arrays"
	-> If you import a package "dsa", subpackages "arrays" will not be imported.	
		* Importing package by "import java.*" wont import the subpackage arrays
		* We need to import subpackages by "import java.arrays.*"

27) Access Modifiers
		* Public
		* Protected
		* Default
		* Private
	
	A class cannot be private or protected except nested class.
	If you are overriding any method, overridden method (i.e. declared in subclass) must not be more restrictive.
	

28) Object Class
	--> 

29) Math Class
	--> abs(), max(), min(), round(), sqrt(), cbrt(), pow(), ceil(), floor(), 
	--> https://www.javatpoint.com/java-math

30) Wrapper Classes
	--> Convert premitive in to object
	--> Uses
		a) Serialization					d) Collection Frameworks deals with object
		b) Synchronization					e) autoboxing means automatically converting premitive to object
		c) provides package to deal with objects		f) unboxing converting object to a primitive (int val = a.intValue())
	

31) strictfp
	Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point variable.
	strictfp can be applied on class, interface and method
	strictfp can't be applied on variable, constructor and abstract methods

32) Java User Input:
	https://www.geeksforgeeks.org/how-to-take-input-from-user-in-java/

	1. Command Line Arguments
		-> Read values from the command line as args[0] or args[1]
		
	2. BufferedReader and InputStreamReader Class
		-> java.io.* Is used for BufferedReaderClass [ BufferedReader, InputStreamReader ]
	
	3. DataInputStream Class
		-> Similar to BufferedReaderClass we can use the DataInputStream class from console.
	
	4. Using Scanner class
		-> Util Class
		-> Initialization Scanner sc = new Scanner(System.in)
		-> .nextBoolean(), .nextInt(), .nextLong(), .nextShort(), .nextLine()[Sentence], .next() [one word]

	-> We generally pass System.in which represents the standard input stream. But if we want to read a file pass the file path at place of System.in
	
	-> Buffered Reader is faster than Scanner as Scanner does lots of post processing like converting to Int or Float.
	-> Buffered Reader is more flexible as we specify the size of stream to read. It can read the larger input than scanner.
	-> BufferedReader is preferred as it is synchronized. While dealing with the multiple threads it is preferred.
	-> Scanner has the little buffer(1KB) than the BufferedReader(8KB).
	
	Buffer
		-> Technique to improve the Input / Output Performance by reducing the number of system calls or disk accesses.
		-> The buffered data is temporarily stored in memory (the buffer) before being processed or written to the output.
		-> Reading larger chunks of the data at once reducing the time spent waiting for the data to be processed.